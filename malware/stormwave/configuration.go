package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"reflect"
	"runtime"
)

const (
	CONFIG_PATH = "%appdata%\\agent\\config.json"
)

type Config struct {
	PullingRate int    `json:"pullingRate"`
	Gateway     string `json:"gateway"`
}

func defaultConfig() Config {
	return Config{
		PullingRate: 10,
		Gateway:     "http://localhost:8080",
	}
}


func fileExists(filename string) bool {
	_, err := os.Stat(filename)
	return !os.IsNotExist(err)
}

func loadConfig(createIfMissing bool) Config {

	fmt.Print("Go runs on ")
	switch os := runtime.GOOS; os {
	case "darwin":
		fmt.Println("OS X.")
	case "linux":
		fmt.Println("Linux.")
	default:
		fmt.Printf("%s.\n", os)
	}

	if !fileExists(CONFIG_PATH) {
		fmt.Println("Config file does not exist")

		if createIfMissing {
			fmt.Println("Creating config file")
			// create configuration file (config.json)
			file, err := os.Create(CONFIG_PATH)

			if err != nil {

			}

			stringConfig, err := json.Marshal(defaultConfig())
			file.WriteString(string(stringConfig))
			file.Close()

		} else {
			fmt.Println("Not creating config file")
			panic("Config file does not exist")
		}

	}

	// load configuration file (config.json)
	file, err := os.ReadFile(CONFIG_PATH)

	if err != nil {
		fmt.Println("Failed to load config file")
		fmt.Println(err)
		panic(err)
	}

	data := Config{}
	err = json.Unmarshal([]byte(file), &data)

	if err != nil {
		fmt.Println("Failed to load config file")
		fmt.Println(err)
		panic(err)
	}

	fmt.Println(data)
	return data
}

func saveConfig(config Config) {

	// save configuration file (config.json)
	file, _ := json.MarshalIndent(config, "", " ")
 
	_ = ioutil.WriteFile("test.json", file, 0644)


}

func updateConfig(key string, value string) Config {
	// edit configuration file (config.json)
	currentConfig := loadConfig(false)

	r := reflect.ValueOf(currentConfig)
	f := reflect.Indirect(r).FieldByName(key)
	f.SetString(value)

	saveConfig(currentConfig)

	return currentConfig
}
