package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net"
	"net/http"
	"os"
	"os/exec"
	"strings"
	"sync"
	"time"
)

type GetPublicIpParams struct {
}

func getPublicIp(params GetPublicIpParams) (string, error) {
	req, err := http.Get("http://ip-api.com/json/")
	if err != nil {
		fmt.Println("")
		return "Error", err
	}
	defer req.Body.Close()

	body, err := ioutil.ReadAll(req.Body)
	if err != nil {
		fmt.Println("")
		return "Error", err
	}

	var ip IP
	json.Unmarshal(body, &ip)

	return ip.Query, nil
}

type GetPrivateIpParams struct {
	Network string `json:"network"`
}
type IP struct {
	Query string
}

func getPrivateIp(params GetPrivateIpParams) string {

	var result strings.Builder
	ifaces, _ := net.Interfaces()
	// handle err
	for _, i := range ifaces {
		addrs, _ := i.Addrs()
		// handle err
		for _, addr := range addrs {
			var ip net.IP
			switch v := addr.(type) {
			case *net.IPNet:
				ip = v.IP
			case *net.IPAddr:
				ip = v.IP
			}
			// process IP address
			result.WriteString(fmt.Sprintf("ip : %s interface %s\n", ip, i.Name))

		}
	}
	return result.String()

}

type NetworkScanParams struct {
	StartIPv4Address string `json:"startIPv4Address"`
	EndIPv4Address   string `json:"endIPv4Address"`
}

func networkScan(params NetworkScanParams) string {
	var scannerPath string = UserHomeDir() + "\\AppData\\Roaming\\agent\\IPv4NetworkScan.ps1"
	var outputPath = UserHomeDir() + "\\AppData\\Roaming\\agent\\scan.txt"

	var pythonPath = UserHomeDir() + "\\AppData\\Local\\Programs\\Python\\Python310\\python.exe"
	var runScript = UserHomeDir() + "\\AppData\\Roaming\\agent\\run.py"

	// check if the scan already exist
	if fileExists(outputPath) {
		fmt.Println("[IP SCANNER] scan.txt already exist. Deleting old scan.")
		err := os.Remove(outputPath)
		if err != nil {
			fmt.Println("Can't remove old scan.txt")
			fmt.Println(err)
			return "Error"
		}
	}

	fullCommand := fmt.Sprintf("powershell.exe -ExecutionPolicy Bypass -File %s -StartIPv4Address %s -EndIPv4Address %s | Out-file -FilePath '%s' ", scannerPath, params.StartIPv4Address, params.EndIPv4Address, outputPath)
	fullCommand = strings.Replace(fullCommand, "\\", "\\\\", -1)

	f, err := os.Create(runScript)

	if err != nil {
		log.Fatal(err)
	}

	_, err2 := f.WriteString(`import subprocess;process=subprocess.Popen(["powershell","` + fullCommand + `" ]);`)

	f.Close()

	if err2 != nil {
		log.Fatal(err2)
	}

	fmt.Println("done")

	fmt.Println(fullCommand)

	cmd := exec.Command(pythonPath, "run.py")

	// Set the working directory if needed
	cmd.Dir = UserHomeDir() + "\\AppData\\Roaming\\agent\\"

	// Create a WaitGroup to wait for the command to finish
	var wg sync.WaitGroup
	wg.Add(1)

	// Set up pipes to capture output
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	// Start the command asynchronously
	err = cmd.Start()
	if err != nil {
		fmt.Println("Error starting command:", err)
		return "Error"
	}

	// Use a goroutine to wait for the command to complete
	go func() {
		defer wg.Done()
		err := cmd.Wait()
		if err != nil {
			fmt.Println("Error:", err)
		}
	}()

	// Wait for the command to finish
	wg.Wait()

	// wait for file creation
	fmt.Println("Waiting for result")

	for {
		time.Sleep(1 * time.Second)
		fmt.Println("Try to read...")

		if fileExists(outputPath) {
			// read the file and send it
			fileData, err := ioutil.ReadFile(outputPath)
			if err != nil {
				fmt.Println("Error during read scan.txt")
			}
			return string(fileData)
		}

	}

}
